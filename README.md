
# Carina Log Processor and Plotter

## Overview

The Carina Log Processor and Plotter is a GUI-based application designed to read, process, and visualize log data from Carina. The application provides a user-friendly interface for selecting data folders, configuring plot settings, generating plots, exporting parsed data, creating new datasets, and getting engine characteristics from thrust.

## Installation

1. Clone the repository:
   ```sh
   git clone https://github.com/UTATRocketry/Carina-Log-Processor-Plotter.git
   ```
2. Navigate to the project directory:
   ```sh
   cd Carina-Log-Processor-Plotter
   ```
3. Install the required dependencies:
   ```sh
   pip install -r requirements.txt
   ```
4. Run the application:
   ```sh
   python main.py
   ``` 

### Start Page 
![image](https://github.com/user-attachments/assets/e2d9a487-77e9-4db8-8e27-596e9e0c69fc)

#### Steps to Start Program
1. Open the application.
2. Enter the folder name that contains the data and event logs. (Ensure that the folder has a "raw" subfolder with the two files "data.log" and "events.log")
3. Choose whether to save the initial plots or not. (By selecting the radio button)
4. Click the "Start Program" button to process and visualize the data across the entire time domain.
5. After all the initial plots are generated you will find yourself in the main program UI.

### Main Program
![image](https://github.com/user-attachments/assets/f6187df7-6213-4124-a0a4-79f42b8a7fc3)

#### Program Tools
##### Replot All
   This tool allows you to replot all the sensors' and actuators' data just as the program did when you first started it. The main difference is you can also define a time frame to plot between. This is useful if you want to visualize everything during a specific time frame. To use this tool follow the steps below:
1. Click on the "Start Time" entry box and enter the desired start time in seconds. If you want to have it plotted from the beginning you can leave this blank.
2. click on the "End Time" entry box and enter the desired end time in seconds. If you want to plot to the very end you can leave this blank.
3. Next choose whether you want to automatically save all plots when they are generated by clicking on the "Yes" or "No" radio button.
4. Finally click on "Replot" and it will generate the plots.

![image](https://github.com/user-attachments/assets/802e0142-7646-475c-9dc4-4028f7166075)

##### Custom Plot 
   This tool allows you to create singular custom plots of multiple sensors on the same plot and also with actuation times displayed. This allows for better visuals of data and what is truly occurring during testing. To use this tool follow the instructions below:
1. Firstly you can give your plot a custom name by entering your desired title in the "Plot Name (optional):" entry box.
2. Then if you would like to use actuation times to help set the timeframe for your custom graph you can select an actuator from the "Actuation Timelines:" dropdown. Then in the dropdown next to it, you can choose an actuation time to autofill the start time for the plot and the end time will be filled with the actuation time right after the one you chose.
3. If you choose not to use actuation times for your start and end times, you can manually enter these times. As done in the previous tool enter the start time and end time in seconds into their respective entry boxes.
4. Now you must choose what data you wish to plot. You can choose a sensor name under the "Left Axis" and "Right Axis" and you can also plot multiple sensors under the left or right axis so long as they have the same unit. You can add more or fewer sensors on one axis by clicking the plus or minus button.
5. Next choose whether you want to add vertical asymptotes for actuation times to your plot by selecting actuators under the "Actuators" title. You can add or remove actuators by using the plus or minus buttons. Note: if you leave the left and right axis as "None" and choose an actuator it will plot the actuator as data and not a vertical asymptote.
6. Finally, choose whether to save the plot automatically on creation by clicking the "Yes or "No" radio buttons.
7. Click "Create Plot" and your new custom plot will be generated.

![image](https://github.com/user-attachments/assets/45ce57aa-7b98-4025-afd2-b49e90093c46)

##### Export Parsed Data
   This tool allows you to export the parsed and processed data produced by the program to CSV. You may also choose a start and stop time to be returned in the CSV. The steps below describe how to use the tool:
1. If you wish to only get portions of the data in a CSV, you can choose to add a start time and end time for the data. Add these times in seconds in the "Start Time" and "End Time:" entry boxes.
2. Then click "Export Data" and the parsed data will be saved into the "\raw" subfolder under the names "parsed_sensor_data.csv" and "parsed_actuator_data.csv".

![image](https://github.com/user-attachments/assets/3d4cf10b-61c1-46de-baae-534c9c1bbfd3)

#### Secondary Pages

##### Logs
   By clicking on the "Logs" button a new page will pop up which contains the logs generated by the program while it's running. This will show any errors and informational log entries made by the program to the program.log file. 
   
![image](https://github.com/user-attachments/assets/3868b24e-41f6-426b-904f-0dbefc19dc2e)

##### Settings
   By clicking on the "Settings" a new page will pop up called "Settings" which allows you to customize some parts of the program. The below settings are available:
**Differentiation Half Step Size** - This is the time in milliseconds that the program will use for the backward and forward steps used in the centring differentiation to get mass flow rate.
**Integration Method** - This is the integration method used by the program for doing numerical integration on a dataset. There are two methods Simpson's and the trapezoidal method. Simpson's tends to be more accurate than the trapezoidal method. Integration is used in a couple of the program's calculations for determining engine characteristics from thrust data.
**Integration Step Size** - This is the forward step size in milliseconds used by the program in integration. Regardless of the integration method used.
**Visual Mode** - This is a switch which allows you to set the program in dark or light mode.

![image](https://github.com/user-attachments/assets/7c5dafef-fcc2-4a74-a89b-83d1ca821463)


## Contributing

We welcome contributions to the project! If you want to add new features or make improvements, please follow these steps:

1. Fork the repository.
2. Create a new branch.
3. Make your changes and commit them with descriptive messages.
4. Push your changes to your fork.
5. Create a pull request detailing the changes you have made.

## Suggested Updates / Next Steps

Here are some suggested updates and next steps for the project:

1. **Configurations Page**: Add a button to the UI in the same box as the "Return" and "Log" buttons. This button would bring the user to a different page and this would allow them to configure certain values used in the program such as the "h" used when differentiating the mass into mass flow rate.
2. **Improve Graph Color System**: Improve the amount of colors available for use in lines on a plot which will increase the number of lines that can be plotted at once. Also, add error handling for this. It would be nice to make the vertical asymptote for actuators a specific shade of one colour so they differ from sensor lines.
3. **Create Ability to Deal with Thrust Data**: Be able to use the thrust from hot fire tests to calculate impulse, exhaust velocity, specific impulse, and Delta V. Maybe Add a separate frame for this
4. **Data Operations Tool** Add frame that allows you to customly perform operation between two data sets e.g.PFM - PCC. This would produce a new dataset you could then plot.
5. **Modularize Visuals**: Add more modularity to the UI's visuals by making chunks of it into customized objects.
6. **Improved Error Handling**: Enhance the application to handle various error scenarios gracefully.
7. **Performance Optimization**: Optimize the log processing and plotting to handle larger datasets efficiently. Multiprocessing may help in some scenarios. 
